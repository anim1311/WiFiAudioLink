
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "BluetoothA2DPSink.h"

#include "gif.h"

TaskHandle_t Task2;
eTaskState Task2State;
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels


#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3c ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
BluetoothA2DPSink a2dp_sink;

String title="";
String artist="";


#define LOGO_HEIGHT   32
#define LOGO_WIDTH    128
// 'logopng', 128x32px
const unsigned char logo_bmp [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0x00, 0x80, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x20, 0x00, 0x80, 0x00, 0x00, 
	0x30, 0xc1, 0x31, 0xf9, 0x81, 0x80, 0x00, 0x03, 0x18, 0x00, 0x60, 0x60, 0x00, 0x80, 0x00, 0x00, 
	0x30, 0xe1, 0x11, 0xf8, 0x81, 0xc0, 0x00, 0x03, 0x10, 0x00, 0x60, 0x20, 0x00, 0x80, 0x00, 0x00, 
	0x30, 0xe3, 0x01, 0x80, 0x03, 0x40, 0x00, 0x03, 0x00, 0x00, 0x60, 0x00, 0x00, 0x80, 0x00, 0x00, 
	0x11, 0xa3, 0x11, 0x81, 0x82, 0x41, 0x8c, 0x3b, 0x18, 0x78, 0x60, 0x63, 0x70, 0x8c, 0x00, 0x00, 
	0x11, 0x22, 0x11, 0x81, 0x86, 0x61, 0x8c, 0x7f, 0x18, 0xfc, 0x60, 0x63, 0xf0, 0x88, 0x00, 0x00, 
	0x19, 0x32, 0x11, 0xf9, 0x86, 0x21, 0x8c, 0x63, 0x19, 0x84, 0x60, 0x63, 0x18, 0x98, 0x00, 0x00, 
	0x19, 0x36, 0x11, 0xf9, 0x84, 0x31, 0x8c, 0xc3, 0x19, 0x86, 0x60, 0x63, 0x18, 0xb0, 0x00, 0x00, 
	0x0a, 0x14, 0x11, 0x81, 0x8f, 0xf1, 0x8c, 0xc3, 0x19, 0x86, 0x60, 0x63, 0x18, 0xb0, 0x00, 0x00, 
	0x0e, 0x1c, 0x11, 0x81, 0x8f, 0xf1, 0x8c, 0x43, 0x19, 0x84, 0x60, 0x63, 0x18, 0x98, 0x00, 0x00, 
	0x0e, 0x1c, 0x11, 0x81, 0x88, 0x19, 0xfc, 0x7f, 0x18, 0xfc, 0x7e, 0x63, 0x18, 0x8c, 0x00, 0x00, 
	0x0e, 0x1c, 0x11, 0x81, 0x98, 0x18, 0xec, 0x3b, 0x18, 0x78, 0x7e, 0x63, 0x18, 0x8e, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0c, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x10, 0x2c, 0x95, 0x11, 0xc3, 0x03, 0x86, 0x1e, 0x08, 0x59, 0x1c, 0x59, 0x11, 0x90, 0x00, 0x00, 
	0x12, 0x24, 0x91, 0x12, 0x44, 0x80, 0x09, 0x26, 0x0e, 0x44, 0x82, 0x49, 0x10, 0x50, 0x00, 0x00, 
	0x12, 0x24, 0x91, 0x10, 0x00, 0x81, 0xc1, 0x22, 0x08, 0x44, 0x8e, 0x49, 0x17, 0xd0, 0x00, 0x00, 
	0x3e, 0x24, 0x91, 0x10, 0x00, 0x82, 0x41, 0x22, 0x08, 0x44, 0x92, 0x49, 0x14, 0x10, 0x00, 0x00, 
	0x21, 0x24, 0x91, 0x12, 0x40, 0x84, 0x41, 0x26, 0x08, 0x44, 0x82, 0x49, 0x12, 0x10, 0x00, 0x00, 
	0x21, 0x24, 0x90, 0xd3, 0x80, 0x83, 0x41, 0x1a, 0x0e, 0x44, 0x9a, 0x48, 0xd3, 0x90, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};



void drawBitLogo(void) {
    display.clearDisplay();

    display.drawBitmap(0,0,logo_bmp, LOGO_WIDTH, LOGO_HEIGHT, 1);
    display.display();
    delay(1000);
}

void drawDetails(String title, String artist) {
  display.clearDisplay();

  display.setTextSize(1);      // Normal 1:1 pixel scale
  display.setTextColor(SSD1306_WHITE); // Draw white text
  display.setCursor(GIF_WIDTH, 0);     // Start at top-left corner
  display.cp437(true);         // Use full 256 char 'Code Page 437' font

  // Not all the characters will fit on the display. This is normal.
  // Library will draw what it can and the rest will be clipped.
  


  display.display();

}



void drawGif( void * pvParameters ){
    Serial.print("new Task2 running on core ");
    Serial.println(xPortGetCoreID());

    for(;;){
            // Clear the buffer.
            display.clearDisplay();
            
            display.setTextSize(1);      // Normal 1:1 pixel scale
            display.setTextColor(SSD1306_WHITE); // Draw white text
            display.setCursor(GIF_WIDTH, 0);     // Start at top-left corner
            display.cp437(true);  

            
            // Draw bitmap on the screen
            display.drawBitmap(0, 0, gif1, GIF_WIDTH, GIF_HEIGHT, 1);
            display.display();
            delay(500);
            // Clear the buffer.
            display.clearDisplay();
            
            // Draw bitmap on the screen
            display.drawBitmap(0, 0, gif2, GIF_WIDTH, GIF_HEIGHT, 1);
            display.display();
            delay(500);
            // Clear the buffer.
            display.clearDisplay();
            
            // Draw bitmap on the screen
            display.drawBitmap(0, 0, gif3, GIF_WIDTH, GIF_HEIGHT, 1);
            display.display();
            delay(500);
            
                // Clear the buffer.
            display.clearDisplay();
            
            // Draw bitmap on the screen
            display.drawBitmap(0, 0, gif4, GIF_WIDTH, GIF_HEIGHT, 1);
            display.display();
            delay(500);
            // Clear the buffer.
            display.clearDisplay();
            
            // Draw bitmap on the screen
            display.drawBitmap(0, 0, gif5, GIF_WIDTH, GIF_HEIGHT, 1);
            display.display();
            delay(500);
    }
}


void avrc_metadata_callback(uint8_t id, const uint8_t *text) {
  switch(id){
     case ESP_AVRC_MD_ATTR_TITLE:
        title = (const char*)text;
        break;
     case ESP_AVRC_MD_ATTR_ARTIST:
        artist = (const char*)text;
        break;
  }
}


void setup() {
    Serial.begin(115200);

    pinMode(5, OUTPUT);
    digitalWrite(5, HIGH);

    // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
    if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
        Serial.println(F("SSD1306 allocation failed"));
        for(;;); // Don't proceed, loop forever
    }

    // Clear the buffer
    display.clearDisplay();
    delay(2000);
    drawBitLogo();    // Draw a small bitmap image
    delay(2000);
    


    
    static const i2s_config_t i2s_config = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN),
        .sample_rate = 44100, // corrected by info from bluetooth
        .bits_per_sample = (i2s_bits_per_sample_t) 16, // the DAC module will only take the 8bits from MSB 
        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
        .communication_format = (i2s_comm_format_t)I2S_COMM_FORMAT_STAND_MSB,
        .intr_alloc_flags = 0, // default interrupt priority
        .dma_buf_count = 8,
        .dma_buf_len = 64,
        .use_apll = false
    };

    a2dp_sink.set_avrc_metadata_callback(avrc_metadata_callback);
    a2dp_sink.set_i2s_config(i2s_config);
    a2dp_sink.start("BluetoothAudioLink");

    Serial.println("Setup done");
    

    xTaskCreatePinnedToCore(drawGif, "Draw Gif", 10000,NULL,1,&Task2,1);
    vTaskSuspend(Task2);
    
}

void loop() {

    Task2State = eTaskGetState(Task2);

    if(a2dp_sink.is_connected()) {
        
        if(Task2State == eSuspended){
            Serial.println("Task2 is suspended");
            vTaskResume(Task2);
        }

        
    } 
}
